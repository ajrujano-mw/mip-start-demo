"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2304],{7802:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var a=n(4848),i=n(8453);const s={sidebar_position:4},o="Development Instance",r={id:"mip_go/define/development_instance",title:"Development Instance",description:"Real-world data is almost always hard to deal with, from collection to",source:"@site/docs/mip_go/4_define/3_development_instance.md",sourceDirName:"mip_go/4_define",slug:"/mip_go/define/development_instance",permalink:"/mip-start-demo/program/mip_go/define/development_instance",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"mipGoSidebar",previous:{title:"Data Schemas",permalink:"/mip-start-demo/program/mip_go/define/data_schemas"},next:{title:"Data Validation",permalink:"/mip-start-demo/program/mip_go/define/data_validation"}},d={},l=[{value:"Generating synthetic data",id:"generating-synthetic-data",level:2},{value:"Shrinking a real-world data-set",id:"shrinking-a-real-world-data-set",level:2},{value:"Next steps",id:"next-steps",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",hr:"hr",p:"p",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"development-instance",children:"Development Instance"}),"\n",(0,a.jsx)(t.p,{children:"Real-world data is almost always hard to deal with, from collection to\r\ncleansing to validation. But developers always need some sort of data for\r\ntesting as they develop a solution."}),"\n",(0,a.jsx)(t.p,{children:"A big mistake is to start testing a solution with real-world (often large)\r\ndata instances from the beginning. The outcome is quite obvious, we end up\r\nhaving to debug the data and the code at the same time, which can become\r\nquite messy and lead to a big waste of time."}),"\n",(0,a.jsx)(t.p,{children:"A good practice is to start developing with a very small instance of the\r\nproblem. The smaller, the better, as long as it's still representative of\r\nthe problem being solved."}),"\n",(0,a.jsx)(t.p,{children:"Next, we discuss two ways to obtain a small development instance."}),"\n",(0,a.jsx)(t.h2,{id:"generating-synthetic-data",children:"Generating synthetic data"}),"\n",(0,a.jsxs)(t.p,{children:["A very small instance can be crafted manually on a spreadsheet starting\r\nfrom the master data (for example, sites, time periods, and products).\r\nIn this case, it\u2019s a good idea to keep the notation simple and suggestive,\r\nsuch as ",(0,a.jsx)(t.code,{children:"S1"}),", ",(0,a.jsx)(t.code,{children:"S2"})," for sites, ",(0,a.jsx)(t.code,{children:"P1"}),", ",(0,a.jsx)(t.code,{children:"P2"}),", ",(0,a.jsx)(t.code,{children:"P3"})," for products, and ",(0,a.jsx)(t.code,{children:"1"}),", ",(0,a.jsx)(t.code,{children:"2"}),",\r\n",(0,a.jsx)(t.code,{children:"3"})," for time periods. Quantitative data, such as demand and price, can be\r\nrandomized or can be chunks copied from actual data, if available."]}),"\n",(0,a.jsx)(t.p,{children:"While this option might not necessarily be doable for some types of machine\r\nlearning projects, it\u2019s definitely a good option for optimization projects."}),"\n",(0,a.jsx)(t.p,{children:"In fact, except for performance, all aspects of an optimization application\r\ncan be tested with small instances. In which case, even commercial solvers\r\nmay be used for free (at occasion we wrote this, no license was required\r\nto use Gurobi to solve models with up to 2K variables and constraints for\r\ndevelopment purposes)."}),"\n",(0,a.jsx)(t.p,{children:"Another advantage of this option is that one can craft instances to stress\r\nand validate the code against situations that the client might face in the\r\nfuture but that are not present in the first datasets provided. Such\r\ninstances are useful for writing unit testing, for example."}),"\n",(0,a.jsx)(t.h2,{id:"shrinking-a-real-world-data-set",children:"Shrinking a real-world data-set"}),"\n",(0,a.jsx)(t.p,{children:"This can be done manually or via script. The goal is to simply restrict the\r\nwhole data to a small subset by throwing away SKU, sites, time periods, or\r\nwhatever makes sense to reduce the instance size."}),"\n",(0,a.jsx)(t.p,{children:"This option usually yields larger instances compared to the synthetic data\r\noption. One big advantage of the shrinking method is that, if you can write\r\na script to generate one instance, then you may be able to easily generate\r\nmultiple instances."}),"\n",(0,a.jsx)(t.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,a.jsx)(t.p,{children:"In both cases, creating small development instances might take time, but\r\nit\u2019s for sure a time worth spending. Besides the debugging time that it can\r\nsave, this practice yields more reliable solutions because of the implied\r\ntesting. In addition, small instances help us better understand the\r\nbehavior of the solution, which then can result in performance improvement and\r\ninnovation."}),"\n",(0,a.jsx)(t.p,{children:"Therefore, we strongly encourage you to take some time now to create one\r\nsmall, representative data set for your problem. You might be surprised by how\r\ninsightful this exercise can be. But if you don't know where to start, it's\r\na good opportunity to contact your Mip Mentor. He can walk you through some\r\nexamples and help you to get started."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.p,{children:"Once you are done, move to the next section to\r\nlearn about data validation."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var a=n(6540);const i={},s=a.createContext(i);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);