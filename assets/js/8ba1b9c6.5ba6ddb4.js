"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1751],{9137:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var a=n(4848),i=n(8453);const s={},o="Data Schemas",r={id:"mip_go/define/data_schemas",title:"Data Schemas",description:"A data schema is a collection of well-defined tables and respective columns,",source:"@site/docs/mip_go/4_define/2_data_schemas.md",sourceDirName:"mip_go/4_define",slug:"/mip_go/define/data_schemas",permalink:"/mip-start-demo/program/mip_go/define/data_schemas",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"mipGoSidebar",previous:{title:"Data",permalink:"/mip-start-demo/program/mip_go/define/data"},next:{title:"Development Instance",permalink:"/mip-start-demo/program/mip_go/define/development_instance"}},h={},l=[{value:"Designing the input schema",id:"designing-the-input-schema",level:2},{value:"Starting from the solution",id:"starting-from-the-solution",level:3},{value:"Starting from the available data",id:"starting-from-the-available-data",level:3},{value:"Designing the output schema",id:"designing-the-output-schema",level:2},{value:"Being Agile",id:"being-agile",level:2}];function c(e){const t={em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"data-schemas",children:"Data Schemas"}),"\n",(0,a.jsx)(t.p,{children:"A data schema is a collection of well-defined tables and respective columns,\r\nalong with other properties such as primary keys, foreign keys constraints,\r\ndata type, and predicates."}),"\n",(0,a.jsxs)(t.p,{children:["Typically, an application needs two data schemas: ",(0,a.jsx)(t.em,{children:"input schema"})," and\r\n",(0,a.jsx)(t.em,{children:"output schema"}),". The application is then developed to consume data from the\r\ninput schema and populate the output schema, which is also known as a\r\n",(0,a.jsx)(t.em,{children:"solution schema"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"It's very important to keep in mind that we need to balance two conflicting\r\ngoals when designing data schemas:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Make the schema friendly to the end-user"}),"\n",(0,a.jsx)(t.li,{children:"Make the schema computationally efficient"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"designing-the-input-schema",children:"Designing the input schema"}),"\n",(0,a.jsx)(t.p,{children:"The process of designing the input schema varies a lot from application to\r\napplication. But there are two main ways to go about it as we discuss next."}),"\n",(0,a.jsx)(t.h3,{id:"starting-from-the-solution",children:"Starting from the solution"}),"\n",(0,a.jsx)(t.p,{children:"If we know what the client expects as an output of the solution, we can develop\r\nthe application with that target in mind and the required input data becomes\r\na consequence of that design."}),"\n",(0,a.jsx)(t.h3,{id:"starting-from-the-available-data",children:"Starting from the available data"}),"\n",(0,a.jsx)(t.p,{children:"If there is not much clarity about the expected output, an alternative is to\r\nstart from the available data. In this case, we recommend starting with the\r\nleast number of tables and columns possible and keep expanding as needed."}),"\n",(0,a.jsx)(t.h2,{id:"designing-the-output-schema",children:"Designing the output schema"}),"\n",(0,a.jsx)(t.p,{children:"The process of designing the output schemas is more straightforward\r\ncompared with the input schema. Basically, we need to identify what the\r\nclient expects to see as an output of the solution and design tables that\r\nachieve what they need."}),"\n",(0,a.jsx)(t.p,{children:"In some cases, the client knows exactly what they need. For example, they\r\nmight expect to feed the output from your solution directly into their IT\r\nsystem. In this case, they might tell you precisely what tables and columns\r\nthey need."}),"\n",(0,a.jsx)(t.p,{children:"In some other cases, the client is looking for dashboards that they can\r\ninteract with. In this case, the goal is more toward designing an output\r\nschema that would facilitate dashboarding."}),"\n",(0,a.jsx)(t.h2,{id:"being-agile",children:"Being Agile"}),"\n",(0,a.jsx)(t.p,{children:"The process of designing data schemas overlaps with the process of scoping\r\nthe problem because when we think about the required input data and reports,\r\nwe are forced to think about the requirements and end goals of the application."}),"\n",(0,a.jsx)(t.p,{children:"In fact, in a certain way, the data schemas establish agreements between\r\ndevelopers and the client. You agree to develop the solution under the\r\nassumption that the data will have that structure and the client agrees that\r\nhe will be able to provide and consume the data in that same structure."}),"\n",(0,a.jsx)(t.p,{children:"But it's crucial to be flexible in this process. Both you and your client\r\nwill likely change your minds several times throughout the development process.\r\nSometimes you will have compelling reasons to change the schema, sometimes\r\nyour client will do. And that's fine. After all, we are adopters of the\r\nAgile methodology. Hence, we understand that the solution will keep evolving\r\nover time, and so will its data schemas."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.p,{children:"In the next section, you will start to prepare a development data instance\r\nand design the input schema of your application."})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var a=n(6540);const i={},s=a.createContext(i);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);